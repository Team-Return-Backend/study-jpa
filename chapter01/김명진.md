# Chapter 1

### SQL을 직접 다룰 때의 문제점

---

- DB는 객체 구조와는 다른 데이터 중심의 구조를 가진다. → DB에 직접 저장, 조회 불가능

→ 개발자가 객체지향 애플리케이션과 DB 중간에서 SQL과 JDBC API로 변환 작업을 해야한다.

\*하지만 CRUD와 같은 반복 작업들이 너무 많다.

**SQL에 의존적인 개발을 하면?**

- 엔티티를 신뢰할 수 없다.
- 진정한 의미의 계층 분할이 어렵다.

→ JPA를 사용하면 개발자가 직접 SQL을 작성하는 것이 아니라 JPA에서 제공하는 API 사용 가능하다.

### 패러다임의 불일치

---

**1-1**

- 애플리케이션 발전 → 복잡성 증가 → 유지보수가 어려운 코드
- RDB는 데이터 중심으로 구조화되어 있고, 객체지향에서 얘기하는 **추상화, 상속, 다형성** 같은 개념이 없다.
- 객체와 RDB는 지향하는 목적이 서로 다르다. → 기능과 표현 방법도 다르다.

→ 객체 구조를 테이블 구조에 저장하는데에 한계가 있다.

이 패러다임의 불일치를 개발자가 중간에서 해결하는데 **많은 시간, 코드 소비**

**1-2 패러다임의 불일치로 발생하는 문제들**

---

**1) 상속**

- 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이 없다. (일부 DB는 상속 지원하지만, 객체 상속과는 약간 다름)
- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- 자바 컬렉션에 객체를 저장하듯이 JPA에 객체를 저장하면 된다.

**2) 연관 관계**

![image](https://github.com/4mjeo/TIL/assets/129156398/443ed81a-7af7-42b1-8805-a74e32b7be4c)

- 객체 - 참조를 통해 다른 객체와 연관 관계를 가지고 참조에 접근해서 연관관계 객체 조회한다.
- 테이블 - 외래키를 통해 다른 테이블과 연관관계를 가지고 조인을 통해 연관된 테이블 조회한다.

- 객체는 참조가 있는 방향으로만 조회할 수 있다.
- 테이블은 외래키 하나로 둘 다 조인이 가능하다.

**3) 객체 그래프 탄생**

![객체그래프탐색](https://github.com/4mjeo/TIL/assets/129156398/97c6f4d0-855d-4a4a-afc5-48c5259eda96)

- SQL을 직접 다루면 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.

→ 객체지향 개발자에게는 큰 제약

JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행해서 연관된 객체를 신뢰하고 마음껏 조회할 수 있다.

> 이 기능을 실제 객체를 사용하는 시점까지 조회를 미룬다고 해서 지연로딩이라 한다.(LAZY)

JPA는 연관된 객체를 즉시 조회할지, 실제 사용되는 시점에 지연해서 조회할지 정의할 수 있다.

**4) 비교**

DB는 기본키의 값으로 각 로우를 구분한다.

> 동등성? equals() 객체 내부의 값 비교 <br>
> 동일성? == 객체 인스턴스의 주소 값 비교

같은 로우를 각각 SQL로 조회하면 동일성 비교에 실패한다.(호출할 때마다 인스턴스가 새로 생성)

하지만, JPA에서는 같은 트랜잭션일 때, 같은 객체가 조회되는 것을 보장한다.

## JPA란?

---

- 애플리케이션과 JDBC 사이에서 동작한다.
- ORM? 객체와 RDB를 매핑한다. (하이버네이트가 가장 많이 사용된다.)

- 하이버네이트 기반으로 새로운 자바 ORM 기술 표준이 만들어졌는데 이게 JPA 이다.
- JPA라는 표준으로 특정 기술 구현에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다.

### 왜 JPA인가?

---

1. **생산성**

컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다.

→ CRUD용 SQL을 직접 작성할 필요가 없다.

1. **유지보수**

SQL의 의존적인 개발을 하면 필드가 하나만 추가되어도 SQL을 모두 수정해야 한다.

→ JPA를 사용하면 해당 엔티티만 수정하면 된다.

1. **패러다임 불일치 해결**
2. **성능**

JPA는 애플리케이션과 DB 사이에서 동작하므로 다양한 성능 최적화 기능을 제공한다.

1. **데이터 접근 추상화와 벤더 독립성**

애플리케이션이 특정 기술에 종속되지 않도록 한다.

# Chapter 3

영속성 관리

> JPA가 제공하는 기능

- 설계 : 엔티티와 테이블 매핑
- 매핑한 엔티티를 실제 사용

## Entity Manager Factory & Entity Manager

---

- **Entity Manager Factory**
  - 전체 어플리케이션에서 하나만 생성한다.
  - 엔티티 매니저 팩토리를 이용하여 엔티티 매니저를 생성한다.
- **Entity Manager**
  - 동시성 문제가 발생할 수 있으므로 스레드별로 생성하여 사용해야만 한다.
  - 엔티티를 수정,삭제,조회 등 엔티티 관련 일을 처리한다. (가상의 DB)
  - 보통 트랜잭션을 시작할 떄 커넥션 획득한다.

## 영속성 컨텍스트

---

**영속성 컨텍스트란?**

- 엔티티를 영구 저장하는 환경이다.
- Entity Manager 를 생성할 때 하나 만들어진다.

> Entity Manager 를 통해 영속성 컨텍스트에 접근 및 관리할 수 있다.

**엔티티 생명주기**

![img1 daumcdn](https://github.com/4mjeo/TIL/assets/129156398/e2b1ea64-85a4-4f09-acdb-a5fe942382f2)

- **비영속** : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 객체를 생성했을 때 아직 저장하지 않은 순수한 객체 상태
  - 영속성 컨텍스트나 DB에 전혀 관련이 없다.
- **영속** : 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트에 의해 관리된다.
  - find(), JPQL을 사용한 엔티티도 영속성 컨텍스트가 관리
- **준영속** : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않는 상태
- **삭제** : 삭제된 상태
  - remove()를 호출하는 순간 엔티티를 삭제한다.
    > 이렇게 삭제된 엔티티는 재사용이 아닌 가비지 컬렉션의 대상이 되도록 하는게 좋다.

**특징**

---

- 엔티티를 식별자 값(@Id)로 구분

> 영속 상태는 식별자 값이 반드시 있어야 한다.

**DB 저장**

- 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는 것

→ **Flush**

**1차 캐시**

- 영속성 컨텍스트가 내부에 가지고 있는 캐시
- 영속 상태의 엔티티는 모두 1차캐시에 저장된다.
- 1차 캐시의 키는 식별자 값을 가진다.

**동일성 보장**

- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
- 같은 키로 조회할 경우 1차 캐시에 있는 같은 엔티티 인스턴스 반환된다.

**트랜잭션을 지원하는 쓰기 지연**

- 트랜잭션을 커밋하면 엔티티 매니저가 영속성 컨텍스트를 flush한다.
- 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT 쿼리를 쌓아둔다.

**변경 감지**

- 객체의 데이터가 변경 사항을 DB에 자동으로 반영하는 기능이다. (update() 필요 없다.)
- 변경 감지는 **영속 상태**의 엔티티에만 적용된다.

> 비영속, 준영속 엔티티는 값을 변경해도 DB에 반영되지 않는다.

- JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.

**지연 로딩**

- 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.

### 플러시

---

flush()는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 것이다.

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교한다.
2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전달한다.

플러시 실행시키는 방법 3가지

- 직접 호출
  - em.flush()를 직접 호출한다.
- 트랜잭션 커밋 시 플러시 자동 호출
  - 트랜잭션 커밋 전 플러시를 호출하지 않으면 어떤 변경사항도 반영되지 않는다.
- JPQL 쿼리 실행 시 플러시 자동 호출
  - 이전에 수정된 영속성 컨텍스트들이 반영되지 않은 결과가 나온다.
  - find() 메소드 호출 시에는 flush() 실행되지 않는다.

**플러시 모드 옵션**

- FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (디폴트)
- FlushModeType.COMMIT : 커밋할 때만 플러시

### 준영속

---

영속성 컨텍스트가 관리하던 영속 상태의 영속성 컨텍스트에서 분리된 상태를 말한다.

> 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

영속상태 → 준영속 상태로 만드는 방법 3가지

- em.detach()
  - 특정 엔티티만 준영속 상태로 전환한다.
- clear()
  - 영속성 컨텍스트를 완전히 초기화해서 모든 엔티티를 준영속 상태로 만든다.
  - 영속성 컨텍스트를 제거하고 새로 만든 것과 같다.
- close()
  - 영속성 컨텍스트를 종료시킨다.
  - 영속성 컨텍스트가 종료되면 자동으로 모든 영속 객체는 준영속 상태가 된다.

**특징**

---

- 영속성 컨텍스트의 기능을 사용할 수 없다.(비영속 상태와 비슷하다)
- 비영속 상태는 식별자 값이 없을 수도 있지만 준영속 상태는 식별자 값을 반드시 가지고 있다.
- 준영속 상태는 영속성 컨텍스트가 관리하지 않아서 지연 로딩 시 문제가 발생한다.

**병합 merge()**

- 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.
- 파라미터로 넘어온 엔티티는 병합후에도 준영속 상태로 남아있다.
- contains() : 영속성 컨텍스트가 파라미터로 넘어온 엔티티를 관리하는지 확인하는 메소드(boolean)

![영속컨텍스트전체](https://github.com/4mjeo/TIL/assets/129156398/8f9e76a6-5cab-4a97-b4bd-30263451bf8c)
